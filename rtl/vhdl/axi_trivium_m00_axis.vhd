library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity axi_trivium_m00_axis is
	generic (
		-- Users to add parameters here
        C_M_AXIS_FIFO_DEPHT : integer := 256;
        C_M_AXIS_FIFO_WIDTH : integer := 32;
		-- Do not modify the parameters beyond this line

		-- Width of S_AXIS address bus. The slave accepts the read and write addresses of width C_M_AXIS_TDATA_WIDTH.
		C_M_AXIS_TDATA_WIDTH : integer := 32;
		-- Start count is the number of clock cycles the master will wait before initiating/issuing any transaction.
		C_M_START_COUNT	: integer := 0
	);
	port (
		-- Users to add ports here
		M_AXIS_TRV_INIT_START : in std_logic;
        M_AXIS_TRV_READY      : in std_logic;
        M_AXIS_TRV_DONE       : in std_logic;
        M_AXIS_TRV_KEYSTREAM  : in std_logic_vector(C_M_AXIS_TDATA_WIDTH-1 downto 0);
        M_AXIS_FIFO_CNT       : out std_logic_vector(31 downto 0);
		-- User ports ends
		-- Do not modify the ports beyond this line

		-- Global ports
		M_AXIS_ACLK	: in std_logic;
		-- 
		M_AXIS_ARESETN	: in std_logic;
		-- Master Stream Ports. TVALID indicates that the master is driving a valid transfer, A transfer takes place when both TVALID and TREADY are asserted. 
		M_AXIS_TVALID	: out std_logic;
		-- TDATA is the primary payload that is used to provide the data that is passing across the interface from the master.
		M_AXIS_TDATA	: out std_logic_vector(C_M_AXIS_TDATA_WIDTH-1 downto 0);
		-- TSTRB is the byte qualifier that indicates whether the content of the associated byte of TDATA is processed as a data byte or a position byte.
		M_AXIS_TSTRB	: out std_logic_vector((C_M_AXIS_TDATA_WIDTH/8)-1 downto 0);
		-- TLAST indicates the boundary of a packet.
		M_AXIS_TLAST	: out std_logic;
		-- TREADY indicates that the slave can accept a transfer in the current cycle.
		M_AXIS_TREADY	: in std_logic
	);
end axi_trivium_m00_axis;

architecture implementation of axi_trivium_m00_axis is

    component fifo_module is
        generic (
            g_WIDTH : natural := 32;
            g_DEPTH : integer := 32
        );
        port (
            i_rst_sync : in std_logic;
            i_clk      : in std_logic;
            -- FIFO Write Interface
            i_wr_en   : in  std_logic;
            i_wr_data : in  std_logic_vector(g_WIDTH-1 downto 0);
            o_full    : out std_logic;  
            -- FIFO Read Interface
            i_rd_en   : in  std_logic;
            o_rd_data : out std_logic_vector(g_WIDTH-1 downto 0);
            o_empty   : out std_logic;
            -- FIFO Count
            o_fifo_cnt : out std_logic_vector(31 downto 0)
        );
    end component fifo_module;
    
    constant max_packet_size : natural := 32;
    
    signal fifo_clk : std_logic := '0';
    signal fifo_rst : std_logic := '0';
    signal fifo_wr : std_logic := '0';
    signal fifo_wr_data : std_logic_vector(C_M_AXIS_FIFO_WIDTH-1 downto 0);
    signal fifo_full : std_logic := '0';
    signal fifo_rd : std_logic := '0';
    signal fifo_rd_data : std_logic_vector(C_M_AXIS_FIFO_WIDTH-1 downto 0);
    signal fifo_empty : std_logic := '0';
    signal fifo_cnt : std_logic_vector(31 downto 0);
    
    signal wait_counter : natural := 0;
    signal block_counter : natural := 0;                                                                                                                                            
                                                                               
	--streaming data valid
	signal axis_tvalid : std_logic;
	--Last of the streaming data 
	signal axis_tlast : std_logic;
    -- Streaming output data
	signal stream_data_out : std_logic_vector(C_M_AXIS_TDATA_WIDTH-1 downto 0);

begin
	-- I/O Connections assignments
    M_AXIS_TVALID	<= axis_tvalid;
	M_AXIS_TDATA	<= stream_data_out;
	M_AXIS_TLAST	<= axis_tlast;
	M_AXIS_TSTRB	<= (others => '1');
	M_AXIS_FIFO_CNT <= fifo_cnt;
	
-- Instatation of the FIFO module
-- FIFO store and outpout the key stream generated by the Trivium module
fifo_module_inst : fifo_module
    generic map (
        g_WIDTH => C_M_AXIS_TDATA_WIDTH,
        g_DEPTH => C_M_AXIS_FIFO_DEPHT
    )
    port map (
        i_rst_sync => fifo_rst,
        i_clk => fifo_clk,
        i_wr_en => fifo_wr,
        i_wr_data => fifo_wr_data,
        o_full => fifo_full,
        i_rd_en => fifo_rd,
        o_rd_data => fifo_rd_data,
        o_empty => fifo_empty,
        o_fifo_cnt => fifo_cnt
    );
	
	-- tvalid generation
    axis_tvalid <= '1' when (M_AXIS_TREADY = '1' and unsigned(fifo_cnt) > 32 and block_counter < max_packet_size and M_AXIS_TRV_INIT_START = '0') else '0';
    -- tlast generation
    -- axis_tlast is asserted when the FIFO is empty
	axis_tlast <= '1' when (block_counter = max_packet_size-1) else '0';
	
	-- FIFO assignements
	fifo_clk <= M_AXIS_ACLK;
	fifo_rst <= '1' when (M_AXIS_ARESETN = '0' or M_AXIS_TRV_INIT_START = '1') else '0';
	
    fifo_wr <= '1' when (M_AXIS_TRV_READY = '1') else '0';
    fifo_wr_data <= M_AXIS_TRV_KEYSTREAM;

    fifo_rd <= '1' when (axis_tvalid ='1') else '0';
	stream_data_out <= fifo_rd_data;
	                 
    process(M_AXIS_ACLK)                                                                           
    begin                                                                                          
        if (rising_edge(M_AXIS_ACLK)) then
            if(M_AXIS_ARESETN = '0' or M_AXIS_TRV_INIT_START = '1') then
                block_counter <= 0;
            else
                if (unsigned(fifo_cnt) > 32 and M_AXIS_TREADY = '1') then
                    if (block_counter < max_packet_size) then
                        block_counter <= block_counter + 1;
                    else
                        block_counter <= 0;
                    end if;
                end if;
            end if;
        end if;                                                                                    
    end process;

end implementation;
