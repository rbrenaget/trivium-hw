library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity axi_trivium_M00_AXIS is
	generic (
		-- Users to add parameters here
        C_M_AXIS_FIFO_DEPHT : integer := 256;
        C_M_AXIS_FIFO_WIDTH : integer := 32;
		-- Do not modify the parameters beyond this line

		-- Width of S_AXIS address bus. The slave accepts the read and write addresses of width C_M_AXIS_TDATA_WIDTH.
		C_M_AXIS_TDATA_WIDTH : integer := 32;
		-- Start count is the number of clock cycles the master will wait before initiating/issuing any transaction.
		C_M_START_COUNT	: integer := 0
	);
	port (
		-- Users to add ports here
		M_AXIS_TRV_INIT_START : in std_logic;
        M_AXIS_TRV_READY      : in std_logic;
        M_AXIS_TRV_DONE       : in std_logic;
        M_AXIS_TRV_KEYSTREAM  : in std_logic_vector(C_M_AXIS_TDATA_WIDTH-1 downto 0);
        M_AXIS_FIFO_CNT       : out std_logic_vector(31 downto 0);
		-- User ports ends
		-- Do not modify the ports beyond this line

		-- Global ports
		M_AXIS_ACLK	: in std_logic;
		-- 
		M_AXIS_ARESETN	: in std_logic;
		-- Master Stream Ports. TVALID indicates that the master is driving a valid transfer, A transfer takes place when both TVALID and TREADY are asserted. 
		M_AXIS_TVALID	: out std_logic;
		-- TDATA is the primary payload that is used to provide the data that is passing across the interface from the master.
		M_AXIS_TDATA	: out std_logic_vector(C_M_AXIS_TDATA_WIDTH-1 downto 0);
		-- TSTRB is the byte qualifier that indicates whether the content of the associated byte of TDATA is processed as a data byte or a position byte.
		M_AXIS_TSTRB	: out std_logic_vector((C_M_AXIS_TDATA_WIDTH/8)-1 downto 0);
		-- TLAST indicates the boundary of a packet.
		M_AXIS_TLAST	: out std_logic;
		-- TREADY indicates that the slave can accept a transfer in the current cycle.
		M_AXIS_TREADY	: in std_logic
	);
end axi_trivium_M00_AXIS;

architecture implementation of axi_trivium_M00_AXIS is

    component fifo_module is
        generic (
            g_WIDTH : natural := 32;
            g_DEPTH : integer := 32
        );
        port (
            i_rst_sync : in std_logic;
            i_clk      : in std_logic;
            -- FIFO Write Interface
            i_wr_en   : in  std_logic;
            i_wr_data : in  std_logic_vector(g_WIDTH-1 downto 0);
            o_full    : out std_logic;  
            -- FIFO Read Interface
            i_rd_en   : in  std_logic;
            o_rd_data : out std_logic_vector(g_WIDTH-1 downto 0);
            o_empty   : out std_logic;
            -- FIFO Count
            o_fifo_cnt : out std_logic_vector(31 downto 0)
        );
    end component fifo_module;
    
    constant max_packet_size : natural := 32;
    
    signal fifo_clk : std_logic := '0';
    signal fifo_rst : std_logic := '0';
    signal fifo_wr : std_logic := '0';
    signal fifo_wr_data : std_logic_vector(C_M_AXIS_FIFO_WIDTH-1 downto 0);
    signal fifo_full : std_logic := '0';
    signal fifo_rd : std_logic := '0';
    signal fifo_rd_data : std_logic_vector(C_M_AXIS_FIFO_WIDTH-1 downto 0);
    signal fifo_empty : std_logic := '0';
    signal fifo_cnt : std_logic_vector(31 downto 0);
    
    signal wait_counter : natural := 0;
    signal block_counter : natural := 0;                                                                                                                                            
                                                                              
    -- Define the states of state machine                                                                           
--	type state is (IDLE, INIT, SEND_STREAM, LAST_DATA);   
	-- State variable                                                                 
--	signal  mst_exec_state : state := IDLE;  
	--streaming data valid
	signal axis_tvalid : std_logic;
--	signal axis_tvalid_delay : std_logic;
	--Last of the streaming data 
	signal axis_tlast : std_logic;
--	signal axis_tlast_delay : std_logic;
    -- Streaming output data
	signal stream_data_out : std_logic_vector(C_M_AXIS_TDATA_WIDTH-1 downto 0);

begin
	-- I/O Connections assignments
    M_AXIS_TVALID	<= axis_tvalid;
	M_AXIS_TDATA	<= stream_data_out;
	M_AXIS_TLAST	<= axis_tlast;
	M_AXIS_TSTRB	<= (others => '1');
	M_AXIS_FIFO_CNT <= fifo_cnt;
	
-- Instatation of the FIFO module
-- FIFO store and outpout the key stream generated by the Trivium module
fifo_module_inst : fifo_module
    generic map (
        g_WIDTH => C_M_AXIS_TDATA_WIDTH,
        g_DEPTH => C_M_AXIS_FIFO_DEPHT
    )
    port map (
        i_rst_sync => fifo_rst,
        i_clk => fifo_clk,
        i_wr_en => fifo_wr,
        i_wr_data => fifo_wr_data,
        o_full => fifo_full,
        i_rd_en => fifo_rd,
        o_rd_data => fifo_rd_data,
        o_empty => fifo_empty,
        o_fifo_cnt => fifo_cnt
    );
	
	-- tvalid generation
	-- axis_tvalid is asserted when the control state machine's state is SEND_STREAM, the FIFO is not empty and AXI stream slave is ready
--    axis_tvalid <= '1' when (M_AXIS_TREADY = '1' and mst_exec_state = SEND_STREAM) else '0';
    axis_tvalid <= '1' when (M_AXIS_TREADY = '1' and unsigned(fifo_cnt) > 32 and block_counter < max_packet_size) else '0';
    -- tlast generation
    -- axis_tlast is asserted when the FIFO is empty
	axis_tlast <= '1' when (block_counter = max_packet_size-1) else '0';
	
	-- FIFO assignements
	fifo_clk <= M_AXIS_ACLK;
	fifo_rst <= '1' when (M_AXIS_ARESETN = '0' or M_AXIS_TRV_INIT_START = '1') else '0';
	
    fifo_wr <= '1' when (M_AXIS_TRV_READY = '1') else '0';
    fifo_wr_data <= M_AXIS_TRV_KEYSTREAM;

    fifo_rd <= '1' when (axis_tvalid ='1') else '0';
	stream_data_out <= fifo_rd_data;
	
--	block_counter <= block_counter when (fifo_empty = '1') else
--	                 block_counter + 1 when (block_counter < max_packet_size) else 0;
	                 
    process(M_AXIS_ACLK)                                                                           
    begin                                                                                          
        if (rising_edge(M_AXIS_ACLK)) then
            if(M_AXIS_ARESETN = '0') then
                block_counter <= 0;
            else
                if (unsigned(fifo_cnt) > 32) then
                    block_counter <= block_counter;
                elsif (block_counter < max_packet_size) then
                    block_counter <= block_counter + 1;
                else
                    block_counter <= 0;
                end if;
            end if;
        end if;                                                                                    
    end process; 

    -- Control state machine implementation
--	process(M_AXIS_ACLK)
--	   variable cnt : natural := 0;                                                                           
--    begin                                                                                          
--        if (rising_edge(M_AXIS_ACLK)) then                                                          
--            if(M_AXIS_ARESETN = '0') then
--                mst_exec_state <= IDLE;
--                cnt := 0;                                                   
--            else
--                case (mst_exec_state) is
--                    when IDLE =>
--                        if (M_AXIS_TRV_INIT_START = '1') then
--                            mst_exec_state <= INIT;
--                        elsif (fifo_empty = '0' and M_AXIS_TRV_READY = '1') then
--                            mst_exec_state <= SEND_STREAM;
--                        end if;
--                    when INIT =>
--                        mst_exec_state <= IDLE;
--                        cnt := 0;
--                    when SEND_STREAM =>
--                        if (M_AXIS_TRV_INIT_START = '1') then
--                            mst_exec_state <= INIT;
--                        elsif (cnt = max_packet_size-1) then
--                            mst_exec_state <= LAST_DATA;
--                            cnt := 0;
--                        elsif (fifo_empty = '0') then
--                            mst_exec_state <= LAST_DATA;
--                        else
--                            cnt := cnt + 1;
--                        end if;
--                    when LAST_DATA =>
--                        mst_exec_state <= IDLE;
--                end case;                                         
--            end if;                                                                                    
--        end if;                                                                                      
--    end process;
    
    -- Input key stream in the FIFO
--    process(M_AXIS_ACLK)                                                                           
--    begin                                                                                          
--        if (rising_edge(M_AXIS_ACLK)) then
--            if (M_AXIS_TRV_READY = '1') then
--                fifo_wr <= '1';
--                fifo_wr_data <= M_AXIS_TRV_KEYSTREAM;
--            else                                                          
--                fifo_wr <= '0';
--            end if;                                                                              
--        end if;                                                                                      
--    end process;  
    
	-- Streaming output data is read from FIFO                                                 
--    process(M_AXIS_ACLK)                                                                           
--    begin                                                                                          
--        if (rising_edge(M_AXIS_ACLK)) then                                                          
--            if(M_AXIS_ARESETN = '0') then
--                fifo_rd <= '0';                                                          
--                stream_data_out <= (others => '0');                                                         
--            elsif (axis_tvalid = '1') then
--                fifo_rd <= '1';                                                                          
--                stream_data_out <= fifo_rd_data;
--            else
--                fifo_rd <= '0';                                                 
--            end if;                                                                                    
--        end if;                                                                                      
--    end process; 
	
    -- Delay the axis_tvalid and axis_tlast signal by one clock cycle                              
    -- to match the latency of M_AXIS_TDATA                                                        
--    process(M_AXIS_ACLK)                                                                           
--    begin                                                                                          
--        if (rising_edge(M_AXIS_ACLK)) then                                                          
--            if(M_AXIS_ARESETN = '0') then                                                              
--                axis_tvalid_delay <= '0';                                                                
--                axis_tlast_delay <= '0';                                                                 
--            else                                                                                       
--                axis_tvalid_delay <= axis_tvalid;                                                        
--                axis_tlast_delay <= axis_tlast;                                                          
--            end if;                                                                                    
--        end if;                                                                                      
--    end process;  

end implementation;
